require 'msf/core'

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Scanner

  def initialize(info = {})
    super(
      'Name'        => 'Custom Port Scanner (simplified)',
      'Description' => %q{
        Auxiliary module that scans a range of TCP ports on a
        target host and reports which ports are open.
      },
      'Author'      => ['Ghofrane'],
      'License'     => MSF_LICENSE
    )

    register_options(
      [
        Opt::RHOST(),
        OptInt.new('STARTPORT', [ true, 'Start port to scan', 1 ]),
        OptInt.new('ENDPORT',   [ true, 'End port to scan',   1024 ])
      ]
    )

    deregister_options('RPORT')
  end

  # run_host is invoked for each host when using Scanner mixin
  def run_host(ip)
    start_p = datastore['STARTPORT'].to_i
    end_p   = datastore['ENDPORT'].to_i

    timeout = 2

    open_ports = []

    print_status("[*] Running module against #{ip}")

    (start_p..end_p).each do |port|
      begin
        sock = Rex::Socket::Tcp.create(
          'PeerHost'      => ip,
          'PeerPort'      => port,
          'ConnectTimeout'=> timeout
        )
        if sock
          sock.close
          print_good("[+] #{ip}:#{port} - Port #{port} is open on #{ip}")
          open_ports << port
        end
      rescue ::Errno::ECONNREFUSED, ::Errno::EHOSTUNREACH, ::Errno::ETIMEDOUT, ::Rex::ConnectionError, ::IOError
        # port closed or not reachable â€” silent
      rescue ::Exception => e
        vprint_error("Error scanning #{ip}:#{port} - #{e.class}: #{e}")
      end
    end

    if open_ports.empty?
      print_status("[*] #{ip} - No open ports found in range #{start_p}-#{end_p}")
    else
      print_status("[*] #{ip} - Open ports on #{ip}: #{open_ports.join(', ')}")
    end
  end
end